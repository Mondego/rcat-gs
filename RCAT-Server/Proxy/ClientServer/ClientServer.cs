using System;
using Alchemy.Server;
using System.Net;
using Alchemy.Server.Classes;
using log4net;
using RCAT;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Proxy
{
    public class ClientServer
    {
        WSServer clientListener = null;
        JsonSerializer serializer = new JsonSerializer();

        protected static ILog Log = null;

        protected void RegisterProxyMethods()
        {
            Proxy.broadcastToClients = BroadcastToClients;
        }

        public ClientServer(ILog log)
        {
            Log = log;
            RegisterProxyMethods();
            // Client server uses Alchemy Websockets
            clientListener = new WSServer(81, IPAddress.Any);
            clientListener.Log.Logger.IsEnabledFor(log4net.Core.Level.Debug);
            clientListener.DefaultOnReceive = new OnEventDelegate(OnReceive);
            clientListener.DefaultOnSend = new OnEventDelegate(OnSend);
            clientListener.DefaultOnConnect = new OnEventDelegate(OnConnect);
            clientListener.DefaultOnDisconnect = new OnEventDelegate(OnDisconnect);
            clientListener.TimeOut = new TimeSpan(0, 5, 0);

            clientListener.Start();
        }

        // Events generated by client connections
        public static void OnConnect(UserContext AContext)
        {
            Log.Info("Client Connection From : " + AContext.ClientAddress.ToString());

            User me = new User();
            me.Name = AContext.ClientAddress.ToString();
            me.Context = AContext;

            Proxy.onlineUsers.Add(me.Name, me.Context);
            Proxy.sendClientConnectToServer(AContext);
        }

        public static void OnReceive(UserContext AContext)
        {
            Log.Info("Client data Received From : " + AContext.ClientAddress.ToString());
            User me = new User();
            me.Name = AContext.ClientAddress.ToString();
            //me.Context = AContext;

            // This object will be sent to server, useless to send UserContext, just need name and position
            me.Context = null;
            try
            {

                string json = AContext.DataFrame.ToString();
                Position pos = JsonConvert.DeserializeObject<Position>(json);

                me.pos = pos;
                Log.Info("Position received from Client: " + pos.top.ToString() + ":" + pos.left.ToString());

                Proxy.sendSetPositionToServer(me);
            }
            catch (Exception e)
            {
                Log.Error("[CLIENTSERVER]: Error parsing Json on OnReceive: ", e);
            }

        }

        public static void OnSend(UserContext AContext)
        {
            Log.Info("[PROXY->CLIENT]: " + AContext.ClientAddress.ToString() + " | " + AContext.DataFrame.ToString());
        }

        public static void OnDisconnect(UserContext AContext)
        {
            Log.Info("Client Disconnected : " + AContext.ClientAddress.ToString());

            Proxy.onlineUsers.Remove(AContext.ClientAddress.ToString());
            Proxy.sendClientDisconnectToServer(AContext);
        }

        public void Stop()
        {
            clientListener.Stop();
        }

        public void BroadcastToClients(ClientBroadcast broadcast)
        {
            foreach (string client in broadcast.clients)
            {
                UserContext cl = Proxy.onlineUsers[client];

                Message m = new Message();

                //User usr = (User)serializer.Deserialize(new JTokenReader(broadcast.data), typeof(User));
                //m.Data = JsonConvert.SerializeObject(usr);

                m.Data = new { Name = (string)broadcast.data["Name"], Position = new Position((int)broadcast.data["pos"]["top"], (int)broadcast.data["pos"]["left"]) };
                m.Type = broadcast.type; 
                string json = JsonConvert.SerializeObject(m);

                cl.Send(json);
            }
        }
    }
}
