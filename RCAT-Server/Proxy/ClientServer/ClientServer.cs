using System;
using System.Threading;
using System.Text;
using Alchemy.Server;
using System.Net;
using Alchemy.Server.Classes;
using log4net;
using RCAT;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Proxy
{
    public class ClientServer
    {
        class LoggingObject
        {
            public long lastupdate;
            public UserContext user;

            public LoggingObject(long _lastupdate, UserContext _user)
            {
                lastupdate = _lastupdate;
                user = _user;
            }
        }

        WSServer clientListener = null;
        JsonSerializer serializer = new JsonSerializer();

        protected static ILog Log = null;

        private static string RoundTripLogName = Properties.Settings.Default.log_roundtrip;

        protected void RegisterProxyMethods()
        {
            Proxy.broadcastToClients = BroadcastToClients;
        }

        public ClientServer(ILog log)
        {
            Log = log;
            RegisterProxyMethods();
            // Client server uses Alchemy Websockets
            clientListener = new WSServer(Properties.Settings.Default.client_listener_port, IPAddress.Any);
            clientListener.Log.Logger.IsEnabledFor(log4net.Core.Level.Debug);
            clientListener.DefaultOnReceive = new OnEventDelegate(OnReceive);
            clientListener.DefaultOnSend = new OnEventDelegate(OnSend);
            clientListener.DefaultOnConnect = new OnEventDelegate(OnConnect);
            clientListener.DefaultOnDisconnect = new OnEventDelegate(OnDisconnect);
            clientListener.TimeOut = new TimeSpan(0, 5, 0);

            clientListener.Start();
        }

        /// <summary>
        /// Events generated by client connections
        /// </summary>
        /// <param name="AContext"></param>
        public static void OnConnect(UserContext AContext)
        {
            Log.Info("[CLIENT->PROXY]: " + AContext.ClientAddress.ToString() + " connected.");

            User me = new User();
            me.n = AContext.ClientAddress.ToString();
            me.Context = AContext;

            Proxy.onlineUsers.Add(me.n, me.Context);
            Proxy.sendClientConnectToServer(AContext);
        }

        /// <summary>
        /// when proxy receives a msg in JSON format from a client, log it, convert it, and forward it to servant layer
        /// </summary>
        /// <param name="AContext"></param>
        public static void OnReceive(UserContext AContext)
        {
            Log.Info("[CLIENT->PROXY]: Received " + AContext.DataFrame.ToString() + " from : " + AContext.ClientAddress.ToString());
            long timestamp = DateTime.Now.Ticks;
            User me = new User();
            me.n = AContext.ClientAddress.ToString();
            try
            {
                string json = AContext.DataFrame.ToString();
                Position pos = JsonConvert.DeserializeObject<Position>(json);
                me.p = pos;
                Log.Info("[CLIENT->PROXY]: Position received from Client: " + pos.t.ToString() + ":" + pos.l.ToString() + ":" + pos.z.ToString());
            }
            catch 
            {
                Log.Warn("[CLIENT->PROXY]: Error parsing Json into a position in ClientServer.OnReceive, JSON message was: " + AContext.DataFrame.ToString());
            }
            Proxy.sendSetPositionToServer(me,timestamp); // so far, the messages received only deal with user position updates

        }

        /// <summary>
        /// when a message is sent from the proxy to one client, log it
        /// </summary>
        /// <param name="AContext"></param>
        public static void OnSend(UserContext AContext)
        {
            Log.Info("[PROXY->CLIENT]: Sent: " + UTF8Encoding.UTF8.GetString(AContext.SentData) + " to: " + AContext.ClientAddress.ToString());
        }

        /// <summary>
        /// when a user disconnects, notify the servant layer
        /// </summary>
        /// <param name="AContext"></param>
        public static void OnDisconnect(UserContext AContext)
        {
            Log.Info("[CLIENT->PROXY]: Client " + AContext.ClientAddress.ToString() + " disconnected.");

            Proxy.onlineUsers.Remove(AContext.ClientAddress.ToString());
            Proxy.sendClientDisconnectToServer(AContext); //handled by the gameserver side of the proxy
        }

        /// <summary>
        /// Stops the TCP Listener for new clients
        /// </summary>
        public void Stop()
        {
            clientListener.Stop();
        }

        
        /// <summary>
        ///send the same data to multiple clients (broadcast contains the data to send and the array of clients to send to) 
        /// </summary>
        /// <param name="broadcast"></param>
        public void BroadcastToClients(ClientMessage broadcast)
        {
            string name = (string)broadcast.Data.SelectToken("n");
            UserContext user = Proxy.onlineUsers[name];
            long lastupdate = user.LastUpdate;

            if (broadcast.TimeStamp >= lastupdate)
            {
                // TODO: Not Thread Safe
                user.LastUpdate = broadcast.TimeStamp;
                foreach (string client in broadcast.clients)
                {
                    try
                    {
                        UserContext cl = Proxy.onlineUsers[client];
                        Message m = new Message();
                        m.Type = broadcast.Type;
                        m.Data = broadcast.Data;
                        //cl.LastUpdate = broadcast.TimeStamp;

                        string json = JsonConvert.SerializeObject(m);

                        cl.Send(json);
                    }
                    catch
                    {
                        Log.Debug("[PROXY->CLIENT]: User " + client + " not found.");
                    }
                }
            }

            user.SentSemaphore.Wait();
            user.SentCounter--;
            if (user.SentCounter < 0)
            {
                user.SentCounter = UserContext.DefaultSentCounter;
                LoggingObject logobj = new LoggingObject(lastupdate, user);
                ThreadPool.QueueUserWorkItem(new WaitCallback(LogRoundTrip), logobj);
            }
            user.SentSemaphore.Release();
            
        }

        static void LogRoundTrip(Object stateInfo)
        {
            // TODO: Not Thread Safe
            LoggingObject logobj = (LoggingObject)stateInfo;
            UserContext user = logobj.user;
            long lastupdate = logobj.lastupdate;

            long now = DateTime.Now.Ticks;
            long interval = now - lastupdate;
            user.RoundtripLog.Append(user.ClientAddress + "\t" + interval.ToString() + "\n");
            
            // Flush every 10 Seconds
            if (now - Proxy.startTime > 100000)
            {
                Proxy.DiskLock.Wait();
                // Example #4: Append new text to an existing file
                using (System.IO.StreamWriter file = new System.IO.StreamWriter(@"C:\Temp\"+RoundTripLogName, true))
                {
                    file.Write(user.RoundtripLog);
                }
                Proxy.DiskLock.Release();
            }
            Proxy.startTime = now;
            user.RoundtripLog.Clear();
        }
    }
}
