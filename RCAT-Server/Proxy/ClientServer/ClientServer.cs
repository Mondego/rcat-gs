using System;
using Alchemy.Server;
using System.Net;
using Alchemy.Server.Classes;
using log4net;
using RCAT;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Proxy
{
    public class ClientServer
    {
        WSServer clientListener = null;
        JsonSerializer serializer = new JsonSerializer();
        protected static int _CLIENTLISTENERPORT = 81; //TODO: replace this line by a call to external config file

        protected static ILog Log = null;

        protected void RegisterProxyMethods()
        {
            Proxy.broadcastToClients = BroadcastToClients;
        }

        public ClientServer(ILog log)
        {
            Log = log;
            RegisterProxyMethods();
            // Client server uses Alchemy Websockets
            clientListener = new WSServer(_CLIENTLISTENERPORT, IPAddress.Any);
            clientListener.Log.Logger.IsEnabledFor(log4net.Core.Level.Debug);
            clientListener.DefaultOnReceive = new OnEventDelegate(OnReceive);
            clientListener.DefaultOnSend = new OnEventDelegate(OnSend);
            clientListener.DefaultOnConnect = new OnEventDelegate(OnConnect);
            clientListener.DefaultOnDisconnect = new OnEventDelegate(OnDisconnect);
            clientListener.TimeOut = new TimeSpan(0, 5, 0);

            clientListener.Start();
        }

        /// <summary>
        /// Events generated by client connections
        /// </summary>
        /// <param name="AContext"></param>
        public static void OnConnect(UserContext AContext)
        {
            Log.Info("[CLIENT->PROXY]: " + AContext.ClientAddress.ToString() + " connected.");

            User me = new User();
            me.Name = AContext.ClientAddress.ToString();
            me.Context = AContext;

            Proxy.onlineUsers.Add(me.Name, me.Context);
            Proxy.sendClientConnectToServer(AContext);
        }

        /// <summary>
        /// when proxy receives a msg in JSON format from a client, log it, convert it, and forward it to servant layer
        /// </summary>
        /// <param name="AContext"></param>
 
        public static void OnReceive(UserContext AContext)
        {
            Log.Info("[CLIENT->PROXY]: Received data from : " + AContext.ClientAddress.ToString());
            User me = new User();
            me.Name = AContext.ClientAddress.ToString();
            //me.Context = AContext;

            // Object me will be sent to servant layer. Useless to send the whole UserContext, just need name and position
            me.Context = null;
            try
            {
                string json = AContext.DataFrame.ToString();
                Position pos = JsonConvert.DeserializeObject<Position>(json);
                me.pos = pos;
                Log.Info("[CLIENT->PROXY]: Position received from Client: " + pos.top.ToString() + ":" + pos.left.ToString());
            }
            catch (Exception e)
            {
                Log.Error("[CLIENT->PROXY]: Error parsing Json into a position in ClientServer.OnReceive: ", e);
            }
            Proxy.sendSetPositionToServer(me); // so far, the messages received only deal with user position updates

        }

        /// <summary>
        /// when a message is sent from the proxy to one client, log it
        /// </summary>
        /// <param name="AContext"></param>
        public static void OnSend(UserContext AContext)
        {
            Log.Info("[PROXY->CLIENT]: To: " + AContext.ClientAddress.ToString() + ", ClientServer sent: " + AContext.DataFrame.ToString());
        }

        /// <summary>
        /// when a user disconnects, notify the servant layer
        /// </summary>
        /// <param name="AContext"></param>
        public static void OnDisconnect(UserContext AContext)
        {
            Log.Info("[CLIENT->PROXY]: Client " + AContext.ClientAddress.ToString() + " disconnected.");

            Proxy.onlineUsers.Remove(AContext.ClientAddress.ToString());
            Proxy.sendClientDisconnectToServer(AContext); //handled by the gameserver side of the proxy
        }

        /// <summary>
        ///when admin decides to stop the proxy 
        /// </summary>
        public void Stop()
        {
            clientListener.Stop();
        }

        
        /// <summary>
        ///send the same data to multiple clients (broadcast contains the data to send and the array of clients to send to) 
        /// </summary>
        /// <param name="broadcast"></param>
        public void BroadcastToClients(ClientMessage broadcast)
        {
            foreach (string client in broadcast.clients)
            {
                try
                {
                    UserContext cl = Proxy.onlineUsers[client];
                    Message m = new Message();
                    m.Type = broadcast.Type;
                    m.Data = broadcast.Data;

                    //broadcast.Data = new { Name = (string)broadcast.data["Name"], Position = new Position((int)broadcast.data["pos"]["top"], (int)broadcast.data["pos"]["left"]) };
                    string json = JsonConvert.SerializeObject(m);

                    cl.Send(json);
                }
                catch (Exception e)
                {
                    Log.Debug("[ClientServer]: User " + client + " not found in proxy. Likely on another proxy?",e);
                }
            }
        }
    }
}
