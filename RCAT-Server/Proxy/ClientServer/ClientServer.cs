using System;
using System.Text;
using Alchemy.Server;
using System.Net;
using Alchemy.Server.Classes;
using log4net;
using RCAT;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Proxy
{
    public class ClientServer
    {
        WSServer clientListener = null;
        JsonSerializer serializer = new JsonSerializer();

        protected static ILog Log = null;

        protected void RegisterProxyMethods()
        {
            Proxy.broadcastToClients = BroadcastToClients;
        }

        public ClientServer(ILog log)
        {
            Log = log;
            RegisterProxyMethods();
            // Client server uses Alchemy Websockets
            clientListener = new WSServer(Properties.Settings.Default.client_listener_port, IPAddress.Any);
            clientListener.Log.Logger.IsEnabledFor(log4net.Core.Level.Debug);
            clientListener.DefaultOnReceive = new OnEventDelegate(OnReceive);
            clientListener.DefaultOnSend = new OnEventDelegate(OnSend);
            clientListener.DefaultOnConnect = new OnEventDelegate(OnConnect);
            clientListener.DefaultOnDisconnect = new OnEventDelegate(OnDisconnect);
            clientListener.TimeOut = new TimeSpan(0, 5, 0);

            clientListener.Start();
        }

        /// <summary>
        /// Events generated by client connections
        /// </summary>
        /// <param name="AContext"></param>
        public static void OnConnect(UserContext AContext)
        {
            Log.Info("[CLIENT->PROXY]: " + AContext.ClientAddress.ToString() + " connected.");

            User me = new User();
            me.n = AContext.ClientAddress.ToString();
            me.Context = AContext;

            Proxy.onlineUsers.Add(me.n, me.Context);
            Proxy.sendClientConnectToServer(AContext);
        }

        /// <summary>
        /// when proxy receives a msg in JSON format from a client, log it, convert it, and forward it to servant layer
        /// </summary>
        /// <param name="AContext"></param>
        public static void OnReceive(UserContext AContext)
        {
            Log.Info("[CLIENT->PROXY]: Received " + AContext.DataFrame.ToString() + " from : " + AContext.ClientAddress.ToString());
            User me = new User();
            me.n = AContext.ClientAddress.ToString();
            //me.Context = AContext;

            // Object me will be sent to servant layer. Useless to send the whole UserContext, just need name and position
            me.Context = null;
            try
            {
                string json = AContext.DataFrame.ToString();
                Position pos = JsonConvert.DeserializeObject<Position>(json);
                me.p = pos;
                Log.Info("[CLIENT->PROXY]: Position received from Client: " + pos.t.ToString() + ":" + pos.l.ToString() + ":" + pos.z.ToString());
            }
            catch 
            {
                Log.Warn("[CLIENT->PROXY]: Error parsing Json into a position in ClientServer.OnReceive, JSON message was: " + AContext.DataFrame.ToString());
            }
            Proxy.sendSetPositionToServer(me); // so far, the messages received only deal with user position updates

        }

        /// <summary>
        /// when a message is sent from the proxy to one client, log it
        /// </summary>
        /// <param name="AContext"></param>
        public static void OnSend(UserContext AContext)
        {
            Log.Info("[PROXY->CLIENT]: Sent: " + UTF8Encoding.UTF8.GetString(AContext.SentData) + " to: " + AContext.ClientAddress.ToString());
        }

        /// <summary>
        /// when a user disconnects, notify the servant layer
        /// </summary>
        /// <param name="AContext"></param>
        public static void OnDisconnect(UserContext AContext)
        {
            Log.Info("[CLIENT->PROXY]: Client " + AContext.ClientAddress.ToString() + " disconnected.");

            Proxy.onlineUsers.Remove(AContext.ClientAddress.ToString());
            Proxy.sendClientDisconnectToServer(AContext); //handled by the gameserver side of the proxy
        }

        /// <summary>
        /// Stops the TCP Listener for new clients
        /// </summary>
        public void Stop()
        {
            clientListener.Stop();
        }

        
        /// <summary>
        ///send the same data to multiple clients (broadcast contains the data to send and the array of clients to send to) 
        /// </summary>
        /// <param name="broadcast"></param>
        public void BroadcastToClients(ClientMessage broadcast)
        {
            foreach (string client in broadcast.clients)
            {
                try
                {
                    UserContext cl = Proxy.onlineUsers[client];
                    if (broadcast.Type != ResponseType.Position || broadcast.TimeStamp >= cl.LastUpdate)
                    {
                        Message m = new Message();
                        m.Type = broadcast.Type;
                        m.Data = broadcast.Data;
                        cl.LastUpdate = broadcast.TimeStamp;

                        string json = JsonConvert.SerializeObject(m);

                        cl.Send(json);
                    }
                }
                catch 
                {
                    Log.Debug("[PROXY->CLIENT]: User " + client + " not found.");
                }
            }
        }
    }
}
