using System;
using System.Text;
using System.Net.Sockets;
using System.Threading;
using System.Net;
using log4net;
using RCAT;

namespace Proxy
{
    public class GameServer
    {
        protected static TcpListener serverListener = null;

        public static ILog Log;

        public int serverPort = 82;

        protected void RegisterProxyMethods()
        {
            Proxy.sendSetPositionToServer = Send;
        }

        public GameServer(ILog log)
        {
            // Servers register their existence and communicate with proxy through TCP
            Log = log;
            RegisterProxyMethods();

            if (serverListener == null)
            {
                try
                {
                    serverListener = new TcpListener(IPAddress.Any, serverPort);
                    ThreadPool.QueueUserWorkItem(serverListen, null);
                }
                catch { Log.Error("Server failed to start"); }
            }

            // Accept commands on the console and keep it alive
        }

        protected void serverListen(object State)
        {
            serverListener.Start();
            while (serverListener != null)
            {
                try
                {
                    serverListener.BeginAcceptTcpClient(RunServer, null);
                }
                catch {/* Ignore */ }
            }
        }

        protected void RunServer(IAsyncResult AResult)
        {
            // Server connection
            TcpClient TcpConnection = null;
            try
            {
                if (serverListener != null)
                    TcpConnection = serverListener.EndAcceptTcpClient(AResult);
            }
            catch (Exception e) { Log.Error("Connect Failed", e); }

            if (TcpConnection != null)
            {
                using (ServerContext SContext = new ServerContext())
                //each server has its own context
                {
                    SContext.gameServer = this;
                    SContext.serverConnection = TcpConnection;
                    SContext.ClientAddress = SContext.serverConnection.Client.RemoteEndPoint;
                    try
                    {
                        while (SContext.serverConnection.Connected)
                        {
                            SContext.serverConnection.Client.BeginReceive(SContext.Buffer, 0, SContext.Buffer.Length, SocketFlags.None, new AsyncCallback(DoReceive), SContext);
                        }
                    }
                    catch (Exception e) { Log.Error("Client Forcefully Disconnected", e); }
                }
            }
        }


        // SERVER SECTION
        // Events generated by servers connecting to proxy
        private void DoReceive(IAsyncResult AResult)
        {
            ServerContext SContext = (ServerContext)AResult.AsyncState;
            int received = 0;

            try
            {
                received = SContext.serverConnection.Client.EndReceive(AResult);
            }
            catch (Exception e) { Log.Error("Client Forcefully Disconnected", e); }

            if (received > 0)
            {
                SContext.sb.Append(UTF8Encoding.UTF8.GetString(SContext.Buffer, 0, received));
                SContext.serverConnection.Client.BeginReceive(SContext.Buffer, 0, SContext.Buffer.Length, SocketFlags.None, new AsyncCallback(DoReceive), SContext);
                SContext.Handler.HandleRequest(SContext);
                if (received == SContext.BufferSize)
                {
                    throw new Exception("[PROXY]: HTTP Connect packet reached maximum size. Are we missing data?");
                }
            }
            else
            {
                SContext.Dispose();
            }
        }

        // Sends client data to the server
        public void Send(User client)
        {

        }

        public void Stop()
        {
        }
    }
}
